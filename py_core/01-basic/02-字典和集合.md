 mypost
title: 02-字典和集合
categories: [Python]
---

## 字典

- 一系列有序的键(key)和值(value)配对组成的元素的集合
- 支持多种类型混合
- python3.7后字典变成有序，python3.5之前，创建字典保存：hash(key)，key的内存地址， value的内存地址 3个值来保存一个键值对，因此底层是一个二维数组，各个键值对存放的位置由hash(key)取余后得出，因此存放位置不是按顺序的。 
- python3.7之后，字典底层是2个数组，一个为一维数组，存放hash(key)取余后的值作为数组的索引，对应索引位置存放键值对在二维数组的索引位置。因此二维数组是一个有序的数组。

```python
d = {"name":"zhangsan", "age":18}
d1 = dict(name="zhangsan",age=18)
d2 = dict({"name":"zhangsan", "age":18})
d3 = dict([("name","zhangsan"),("age",18)])
print(d==d1==d2==d3)
# True
```

## 集合

- 一系列唯一，无序的元素的集合
- 支持多种类型混合

```python
s = {1,2,3,4}
s1 = set([1,2,3,4])
print(s==s1)
# True
```

- 通过字典key可以获取对应元素的value
- 使用字典名称.get()方法也可以通过key获取对应value，如若不存在这个key，会返回指定的默认值

```python
d = {"name":"zhangsan", "age":18}
print(d['name']) # "zhangsan"
d['sex'] # 如若不存在这个key，会直接抛出异常
# Traceback (most recent call last): File "", line 1, in KeyError: 'sex'

d.get('sex', None) # 不存在sex这个key，返回指定的默认值None
# None
```

- 想要判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断。

```python
s = {1, 2, 3}
1 in s
# True
10 in s
# False
d = {'name': 'jason', 'age': 20}
'name' in d
# True
'location' in d
# False
```

### 字典和集合也支持增删改查

```python

d = {'name': 'jason', 'age': 20}
d['gender'] = 'male' # 增加元素对'gender': 'male'
d['dob'] = '1999-02-01' # 增加元素对'dob': '1999-02-01'
d
# {'name': 'jason', 'age': 20, 'gender': 'male', 'dob': '1999-02-01'}
d['dob'] = '1998-01-01' # 更新键'dob'对应的值 
d.pop('dob') # 删除键为'dob'的元素对
# '1998-01-01'
d
# {'name': 'jason', 'age': 20, 'gender': 'male'}

s = {1, 2, 3}
s.add(4) # 增加元素4到集合
s
# {1, 2, 3, 4}
s.remove(4) # 从集合中删除元素4
s.pop() # 集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用
# 1
s
# {2, 3}
```

### 字典和集合排序

- 字典排序 升序/降序 根据字典的键(key)/值(value)排序

```python
d = {'a':1, 'c':4, 'd':7, 'e':2, 'b':5}
d_sorted_key = sorted(d.items(), key=lambda x:x[0]) # 根据字典key的升序
d_sorted_value = sorted(d.items(), key=lambda x:x[1]) # 根据字典value升序
print(d_sorted_key) # [('a', 1), ('b', 5), ('c', 4), ('d', 7), ('e', 2)]
print(d_sorted_value) # [('a', 1), ('e', 2), ('c', 4), ('b', 5), ('d', 7)]
```

- 集合排序

```python

s = {3, 4, 2, 1}
sorted(s) # 对集合的元素进行升序排序
[1, 2, 3, 4]
```

### 性能差异

```python
# 先看列表存储一部分数据，再进行查找

def find_product_price(products, product_id):
    for id, price in products:
        if id == product_id:
            return price
    return None 
     
product_list = [
    (143121312, 100), 
    (432314553, 30),
    (32421912367, 150) 
]

print('The price of product 432314553 is {}'.format(find_product_price(product_list, 432314553)))

# 输出
# The price of product 432314553 is 30
# 假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。

# 再看字典存储一部分数据 进行查找

products_ = {
  143121312: 100,
  432314553: 30,
  32421912367: 150
}
print('The price of product 432314553 is {}'.format(products[432314553])) 

# 输出
# The price of product 432314553 is 30
# 用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值
```