---
layout: mypost
title: 03-装饰器
categories: [Python]
---

## 核心概念

### 函数-装饰器

- 在python中，函数也是对象，也可以把函数赋值给变量

```python
def get_message(message):
    print(f"hello, {message}")

send_message = get_message
send_message("china") # hello, china

# 把函数func赋值给变量send_message，调用send_message等同于调用func
```

- 把函数当作参数传入另一个函数

```python
def get_message(message):
    print(f"hello, {message}")

def root_call(func, message):
    print(func(message))

root_call(get_message, "CN") # hello, CN
```

- 在函数里定义函数，函数的嵌套

```python
def func(message):
    def get_message(message):
        print(f"hello, {message}")
    return get_message(message)

func("NB") # hello, NB

# 函数func里定义了get_message函数，调用后作为func的返回值返回
```

- 函数的返回值也可以是函数对象(闭包)

```python
def func_closure():
    def get_message(message):
        print(f"hello, {message}")
    return get_message

send_message = func_closure()
send_message("yyds") # hello, yyds

# 函数func_closure()的返回值是函数对象get_message对象本身，然后将其赋值给变量send_message,再调用send_message('yyds'),最后输出hello, yyds
```

```python
def my_decorator(func):
    def wrapper():
        print("wrapper of decorator")
        func()
    return wrapper

def greeter():
    print(f"hello, dddd")

greet = my_decorator(greeter)
greet()
"""
wrapper of decorator
hello, dddd
"""

# 变量 greet 指向了内部函数 wrapper()，而内部函数 wrapper() 中又会调用原函数 greet()，因此，最后调用 greet() 时，就会先打印'wrapper of decorator'，然后输出'hello world'。
# 函数 my_decorator() 就是一个装饰器，它把真正需要执行的函数 greet() 包裹在其中，并且改变了它的行为，但是原函数 greet() 不变。

# 第二种写法
@my_decorator
def greet():
    print('hello world')

greet()

# 这里的@，我们称之为语法糖，@my_decorator就相当于前面的greet=my_decorator(greet)语句，只不过更加简洁。
# 因此，如果你的程序中有其它函数需要做类似的装饰，你只需在它们的上方加上@decorator就可以了，这样就大大提高了函数的重复利用和程序的可读性。
```

## 带参数的装饰器



